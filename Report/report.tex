\documentclass[a4paper,10pt]{article}
\usepackage{hyperref}
\usepackage{pstricks}
\usepackage{tikz}
\usepackage{helvet}
\usepackage{ulem}
\usepackage{amsfonts}
\bibliographystyle{plain}
\pagestyle{empty}

% PDF settings
\hypersetup{%
  pdftitle={An Overview of Gentry's Fully Homomorphic Encryption Scheme}, %
  pdfauthor={Adam Risi and Ross Snider}, %
}

\title{An Overview of Gentry's Fully Homomorphic Encryption Scheme}
\author{Adam Risi \and Ross Snider}

\begin{document}
\maketitle
\titlepage
\tableofcontents
\pagebreak

\begin{abstract}
  In a 1978 paper\cite{rad-priv} inspired by the multiplicative
  homomorphic properties of the RSA cryptosystem, Rivest, Shamir and
  Dertouzos detailed essential properties of what they called a
  \textit{privacy homomorphism} -- a cryptographic scheme that would
  allow third party processing of encrypted data without access to any
  plaintext or private key information. While partial strides toward
  such a system have been made over the past thirty years, most
  cryptographers believed that no such scheme would ever be
  realized. Craig Gentry of Stanford University fully realized such a
  scheme in his 2009 PhD dissertation ''A Fully Homomorphic Encryption
  Scheme.''\cite{gentry-thesis} In this paper, we describe a similar
  (fully homomorphic) scheme over the integers (also invented by
  Gentry)\cite{gentry-integer}, which remains conceptually identical
  to the original lattice scheme but with the added benefit that it is
  much simplier.
\end{abstract}

\section{Introduction}
In his 2009 paper ``Fully Homomorphic Encryption using Ideal
Lattices''\cite{gentry-lattice}, Craig Gentry made two important
contributions to the field. First, he defined a partially homomorphic
scheme which was interesting in its own right. This scheme was robust
enough to allow third party contributions of a nearly arbitrary number
of additions and many multiplications, beating out the
Boneh-Goh-Nissim cryptosystem, which remained a leader in the field
for quite some time.

Unfortunately, Gentry's partially homomorphic scheme suffered from the
fact that as computations are performed on the ciphertexts, noise is
introduced in the output ciphertexts. This limited the malleability of
the scheme -- after some number of computations, the error vectors
would grow too large and decryption would become invalid.

Gentry realized that if he could find some way to eliminate the
growing noise implicit in the scheme, he could modify his original
scheme to allow an arbitrary number of additions and
multiplications. In turn, this would allow him to perform any
computable function on encrypted data.

Aware that successfully decrypting and subsequently re-encrypting a
given ciphertext would eliminate its noise vector, Gentry asked ''why
not allow the third party to decrypt the ciphertexts \textit{homomorphically}?''
The third party would be able to remove the growing noise from
ciphertexts. At the same time, asking the third party to do the
decryption homomorphically would maintain the privacy of the private
key.

If the noise introduced by a homomorphic evaluation of the decryption
function is less than what the scheme is capable of handling, then the
scheme can chain together homomorphic evaluations of decryption with
homomorphic evaluations of the target computable functions, resulting
in a scheme that can handle a computable function of any complexity.

\section{History}
While a fully homomorphic encryption scheme is new, the idea is
not. The inspiration for a fully homomorphic encryption system came
from an interesting property in RSA.

\begin{eqnarray*}
c = m ^{e} \bmod n\\
m = c ^{d} \bmod n 
\end{eqnarray*}

If we multiply the ciphertext $c$ by $y ^{e}$, we can see that the
decryption of $ cy^{e} $ will yield $my$, or the plaintext multiplied
by the value y. This \textit{partial homomorphism} lead to greater
investivation by Rivest, Adleman, and Dertouzos.

Proposed in 1978 by Rivest, Adleman, and Dertouzos, ``privacy
homomorphisms'' are the first known example of what came to be called
``fully homomorphic encryption.'' Rivest, Adleman, and Dertouzos
proposed a thought experiment: Imagine a loan company who stored its
data at an off site location. Since the data about loans is sensitive,
the loan company decided to have all of its data encrypted. Now, a
problem becomes apparent: if the loan data is encrypted and stored off
site, then how would the loan company be able to query it? The clear
solution is to have the 3rd party query the encrypted loan
information; however, because the data is encrypted, queries can not
be performed. Rivest, Adleman, and Dertouzos proposed ``privacy
homomorphisms,'' a theoretical encryption system where data could be
stored and queried, in a completely encrypted environment.

Between 1978 and today, a number of other schemes have been shown to
be partially homomorphic. Paillier, Boneh-Goh-Nissim, and ElGamal all
exhibited partial homomorphism over some operations.

\section{Background}

\subsection{Multiplicative Homomorphism in RSA}
In RSA, the encryption function $\varepsilon$ and decryption function
$\delta$ provide a multiplicative homomorphism. First, recall:

\begin{eqnarray*}
n &=& pq\\
\phi(n) &=& (p-1)(q-1)\\
de &=& 1 \bmod \phi(n)\\
m^{de} \bmod n &=& m \bmod n\\
\varepsilon_{RSA}(m) &=& m^e \bmod n\\
\delta_{RSA}(c) &=& c^d \bmod n\\
\end{eqnarray*}
Decrypting a multiplication of two ciphertexts yeilds the multiplication of the corresponding plaintexts.
\begin{eqnarray*}
\varepsilon_{RSA}(x) \times \varepsilon_{RSA}(y) &=& x^e y^e \bmod n\\
\delta(\varepsilon_{RSA}(x) \times \varepsilon_{RSA}(y)) &=& (x^e y^e)^d \bmod n\\
&=& x^{de} y^{de} \bmod n\\
&=& x y \bmod n
\end{eqnarray*}

\subsection{Partially Homomorphic and Fully Homomorphic Encryption}
To generalize this property, consider the contraint that
$\delta(\mathcal{F}(\varepsilon(m_1), \varepsilon(m_2), ...,
\varepsilon(m_n))) = \mathcal{F}(m_1, m_2, ..., m_n)$ for some set of
functions $\mathcal{F}$ on all $m_i$ in the plaintext space. We say
that an encryption scheme is \textit{partially homomorphic} if
$\mathcal{F}$ is a (finite or infinite) proper subset of computable
functions. We say that an encryption scheme is \textit{fully
  homomorphic} if $\mathcal{F}$ is the set of all computable
functions.

\subsection{Constructing a Boolean Circuit}
Boolean circuits comprised of AND, OR and NOT gates are Turing
Complete. Every computable function has a circuit version. In fact,
any Turing Machine $T$ can be turned into a boolean circuit of size $k
\times |T| \times log(|T|)$ for a small constant k. Thus to show that
an encryption scheme $Y$ is \textit{partially homomorphic}, it is
sufficient to show that an encryption scheme $Y$ can handle boolean
circuits of a particular variety. To show that an encryption scheme is
\textit{fully homomorphic}, it is sufficient to show that an
encryption scheme can handle every possible boolean
circuit. Furthermore, it can be shown that to get homomorphic AND, OR,
and NOT gates, it sufficies to have homomorphic addition and
homomorphic multiplication.
\begin{eqnarray*}
\label{aoi}
\mathrm{NOT}(x) &=& 1+x \bmod 2\\
\mathrm{AND}(x,y) &=& xy \bmod 2\\
\mathrm{OR}(x,y) &=& (1+x)(1+y) + 1 \bmod 2
\end{eqnarray*}

\section{Gentry's Homomorphic Encryption Scheme}

\subsection{Partially Homomorphic Encryption}
To begin, Gentry proposes a simple partially homomorphic encryption
scheme over the integers:

Key Generation: The key, $p$, is a randomly generated $\lambda^2$ bit
odd integer.

Encryption: To encrypt a single bit $ m \in \{0,1\} $, pick a
ciphertext integer whose residue mod $ p $ has the same parity as
$m$. This ciphertext integer can be described as $ c = pq + m' $,
where $ p $ is the private key, $m'$ is a random $\lambda$ bit integer
with least significant bit $m$, and $q$ is a random $\lambda^5$ bit
integer.

Decryption: Decryption under this scheme is simple, the given a
ciphertext $c$, $ m = ( c \bmod p) \bmod 2 $. Without the key $p$, the
problem is intractable as described in Section \ref{app-gcd}

To make this a public key system, we simply issue the 3rd party a
series of encryptions of $0$. The 3rd party can then add one to any
encryption of $0$ to have it decrypt to $1$, and leave it alone to
have it decrypt to $0$.

We can show that this is homomorphic by investigating the
multiplication and addition of two cithpertexts, $ \varepsilon(x) $
and $ \varepsilon(y) $.

\paragraph{Multiplication}
\begin{eqnarray*}
\varepsilon(x) \times \varepsilon(y) &=& (m_1 + p q_1)(m_2 + p q_2)\\
\delta(\varepsilon(x) \times \varepsilon(y))&=& m_1m_2 + m_1pq_2 + m_2pq_1 + p^2q_1q_2 \bmod p\\
&=& m_1m_2 \bmod 2
\end{eqnarray*}

\paragraph{Addition}
\begin{eqnarray*}
\varepsilon(x) + \varepsilon(y) &=& m_1 + p q_1 + m_2 + p q_2\\
\delta(\varepsilon(x) + \varepsilon(y))&=& m_1 + m_2 + pq_1 + pq_2 \bmod p\\
&=& m_1 + m_2 \bmod 2
\end{eqnarray*}

With homomorphic multiplication and addition, we can use the
transformations listed in Section \ref{aoi} to achieve boolean
circuits, and therefore computable functions.

\subsubsection{Noise}
As sequential operations are preformed on ciphertext, a number of
excess ``noise'' is introduced. For example, by preforming a single
addition and multiplication, a large term appears:

\begin{eqnarray*}
\varepsilon(x) + \varepsilon(y) \times \varepsilon(z) &=& (m_1 + m_2 + pq_1 + pq_2)(m_3 + pq_3)\\
&=&m_1m_3 + m_2m_3 + p^2q_1q_3 + p^2q_2q_3\\
&=&m_3(m_1 + m_2) + p^2(\mathbf{q_1q_3 + q_2q_3})\\
&=&m_3(m_1 + m_2) + p^2(\mathbf{\gamma})
\end{eqnarray*}

As the term $\gamma$ grows (approaching p), a problem arises. The
growing term $\gamma$ limits the number of operatios perfomed on the
ciphertext. This causes a boundary, making some functions

\subsection{Bootstrapping}

\subsection{Fully Homomorphic Encrpytion}

\subsection{Security}
Gentry proposes a fully homomorphic encryption scheme that relies on
two different ``difficult problems'' for security, the
\textbf{Approximate Greatest Common Divisor} problem, and the
\textbf{Sparse Subset Sum} problem.

\subsubsection{Approximate Greatest Common Divisor}
\label{app-gcd}
The approximate GCD problem is, given a set of $ n _{i} + pq_{i} $,
determine p. The best known algorithm is exponential time in the size
of inputs.


\subsubsection{Sparse Subset Sum}
The sparse subset sum problem is a variant of the common subset sum
problem. In the classic Subset Sum problem, we are given a set $
\mathbb{s} $ and a target value $t$, and are asked for a subset of $
\mathbb{s} $ whose \textit{sum} is equal to $t$. In the \textit{Sparse
  Subset Sum} problem, the simple addition that the cardinality of the
answer set must be much smaller than the cardinality of $ \mathbb{s}
$. This problem, and its parent problem (Subset Sum), have been shown
to be intractable reasonably sized $ \mathbb{s} $.

\section{Fully Homomorphic Encryption in the Future}

\pagebreak
\bibliography{report}
\end{document}


